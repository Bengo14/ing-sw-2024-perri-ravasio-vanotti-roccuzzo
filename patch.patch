diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/Deck.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/Deck.java
index 360eab3..943a3cd 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/Deck.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/Deck.java
@@ -34,6 +34,9 @@ public class Deck {
     }
     /**
      * This method initializes the deck.
+     * HashMaps with the card id as key and the card itself as value are also initialized here.
+     * The latter are later used for network communication purposes.
+     * At last, this method generates the seed used to randomize the shuffle process.
      * */
     public static void initDeck() {
         randomGenerator = new Random(System.currentTimeMillis());
@@ -44,7 +47,7 @@ public class Deck {
         initHashMaps();
     }
     /**
-     * This method shuffles the deck.
+     * This method shuffles the deck using the previously initialized seed.
      * */
     private static void shuffleDeck() {
         Collections.shuffle(goldCardsDeck,randomGenerator);
@@ -70,7 +73,7 @@ public class Deck {
         }
     }
     /**
-     * This method generates the resource cards deck.
+     * This method generates the resource cards deck by parsing the cards from the respective json file.
      * */
     private static void generateResourceCardsDeck() {
         Gson gson = new Gson();
@@ -83,7 +86,7 @@ public class Deck {
         }
     }
     /**
-     * This method generates the gold cards deck.
+     * This method generates the gold cards deck by parsing the cards from the respective json file.
      * */
     private static void generateGoldCardsDeck() {
         Gson gson = new Gson();
@@ -95,7 +98,8 @@ public class Deck {
         }
     }
     /**
-     * This method generates the objective cards deck.
+     * This method generates the objective cards deck by parsing the cards from the respective json file.
+     * The deserializer is used to parse the different types of objectives, respecting inheritance.
      * */
     private static void generateObjectiveCardsDeck(){
         ObjectiveDeserializer deserializer = new ObjectiveDeserializer("type");
@@ -113,7 +117,7 @@ public class Deck {
         }
     }
     /**
-     * This method generates the starting cards deck.
+     * This method generates the starting cards deck by parsing the cards from the respective json file.
      * */
     private static void generateStartingCardsDeck(){
         Gson gson = new Gson();
@@ -125,8 +129,8 @@ public class Deck {
         }
     }
     /**
-     * This method draws a card from the resource deck.
-     * @return the drawn card.
+     * This method draws a card and removes it from the resource deck.
+     * @return the drawn card, null if the deck is empty.
      * */
     protected static ResourceCard drawCardFromResourceDeck(){
         if(resourceCardsDeck.isEmpty())
@@ -134,8 +138,8 @@ public class Deck {
         return resourceCardsDeck.removeLast();
     }
     /**
-     * This method draws a card from the gold deck.
-     * @return the drawn card.
+     * This method draws a card  and removes it from the gold deck.
+     * @return the drawn card, null if the deck is empty.
      * */
     protected static GoldCard drawCardFromGoldDeck(){
         if(goldCardsDeck.isEmpty())
@@ -143,8 +147,8 @@ public class Deck {
         return goldCardsDeck.removeLast();
     }
     /**
-     * This method draws a card from the objective deck.
-     * @return the drawn card.
+     * This method draws a card  and removes it from the objective deck.
+     * @return the drawn card, null if the deck is empty.
      * */
     protected static Objectives drawCardFromObjectivesDeck(){
         if(objectiveCardsDeck.isEmpty())
@@ -152,8 +156,8 @@ public class Deck {
         return objectiveCardsDeck.removeLast();
     }
     /**
-     * This method draws a card from the starting deck.
-     * @return the drawn card.
+     * This method draws a card  and removes it from the starting deck.
+     * @return the drawn card, null if the deck is empty.
      * */
     public static StartingCard drawCardFromStartingDeck(){
         if(startingCardsDeck.isEmpty())
@@ -197,7 +201,7 @@ public class Deck {
     }
     /**
      * This method returns the gold card on top of the deck.
-     * @return the gold card on top of the deck.
+     * @return the gold card on top of the deck, null if the deck is empty.
      * */
     public static GoldCard getGoldCardOnTop() {
         if(!goldCardsDeck.isEmpty())
@@ -238,28 +242,28 @@ public class Deck {
         }
     }
     /**
-     * This method sets the gold cards deck.
+     * This method sets the gold cards deck. Used when parsing a previous match from a json file.
      * @param goldCardsDeck the gold cards deck.
      * */
     public static void setGoldCardsDeck(List<GoldCard> goldCardsDeck) {
         Deck.goldCardsDeck = goldCardsDeck;
     }
     /**
-     * This method sets the resource cards deck.
+     * This method sets the resource cards deck. Used when parsing a previous match from a json file.
      * @param resourceCardsDeck the resource cards deck.
      * */
     public static void setResourceCardsDeck(List<ResourceCard> resourceCardsDeck) {
         Deck.resourceCardsDeck = resourceCardsDeck;
     }
     /**
-     * This method sets the starting cards deck.
+     * This method sets the starting cards deck. Used when parsing a previous match from a json file.
      * @param startingCardsDeck the starting cards deck.
      * */
     public static void setStartingCardsDeck(List<StartingCard> startingCardsDeck) {
         Deck.startingCardsDeck = startingCardsDeck;
     }
     /**
-     * This method sets the objective cards deck.
+     * This method sets the objective cards deck. Used when parsing a previous match from a json file.
      * @param objectiveCardsDeck the objective cards deck.
      * */
     public static void setObjectiveCardsDeck(List<Objectives> objectiveCardsDeck) {
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/DiagonalPatternObjective.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/DiagonalPatternObjective.java
index aecc64e..142ab8a 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/DiagonalPatternObjective.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/DiagonalPatternObjective.java
@@ -2,7 +2,7 @@ package it.polimi.sw.gianpaolocugola47.model;
 
 /**
  * This class represents pattern-oriented objectives, i.e. objectives that give points only if a certain card
- * pattern is present on a given player table.
+ * pattern is present on a given player table. It extends the Objectives class.
  */
 public class DiagonalPatternObjective extends Objectives {
 
@@ -39,7 +39,7 @@ public class DiagonalPatternObjective extends Objectives {
         return isAscending;
     }
     /**
-     * This method checks the pattern and computes the points.
+     * This method checks if the pattern is present on a given board and, if that is the case, computes the points.
      * @param playerTable the player table to check.
      * @return the points computed * patterns.
      */
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/GoldCard.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/GoldCard.java
index 6bfe161..c424cf8 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/GoldCard.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/GoldCard.java
@@ -3,7 +3,9 @@ package it.polimi.sw.gianpaolocugola47.model;
 import java.util.ArrayList;
 /**
  * This class represents all the gold cards.
- * Have the required of a card and the points that can do.
+ * It extends the ResourceCard class.
+ * It contains the resources required to play the card, the points for corners, the points for items, the item required
+ * plus the ResourceCard attributes.
  */
 public class GoldCard extends ResourceCard {
     private ArrayList<Resources> resourcesRequired;
@@ -35,6 +37,11 @@ public class GoldCard extends ResourceCard {
         return resourcesRequired;
     }
 
+    /**
+     * This method return the resourcesRequired attribute in a string format using ASCII escape codes to
+     * represent the respective colors. Used for printing gold cards in the CLI.
+     * @return :
+     */
     public String resourcesRequiredToString() {
         StringBuilder retString = new StringBuilder();
         for (Resources resource : resourcesRequired) {
@@ -44,7 +51,8 @@ public class GoldCard extends ResourceCard {
     }
 
     /**
-     * This method return the points condition of the card.
+     * This method returns a character representing the points condition of the card.
+     * Used for printing gold cards in the CLI.
      * @return the points condition of the card.
      */
     public String pointConditionToString() {
@@ -54,11 +62,11 @@ public class GoldCard extends ResourceCard {
         if (pointsForItems) {
             return Character.toString(itemRequired.getSymbol());
         } else
-            return "N/A";
+            return "";
     }
 
     /**
-     * This method return if the card give points for corners.
+     * This method returns if the card give points for corners.
      * @return true if the card give points for corners, false otherwise.
      */
     public boolean isPointsForCorners() {
@@ -66,14 +74,14 @@ public class GoldCard extends ResourceCard {
     }
 
     /**
-     * This method return the item required for the card.
+     * This method returns the item required for the card.
      * @return the item required for the card.
      */
     public Items getItemRequired() {
         return itemRequired;
     }
     /**
-     * This method return if the card give points for items.
+     * This method returns whether the card give points for items or not.
      * @return true if the card give points for items, false otherwise.
      */
     public boolean isPointsForItems() {
@@ -81,7 +89,7 @@ public class GoldCard extends ResourceCard {
     }
 
     /**
-     * This method update the resource counter after a card is placed.
+     * This method updates the resource counter after a card is placed.
      * @param counter the counter to update.
      */
     @Override
@@ -100,9 +108,9 @@ public class GoldCard extends ResourceCard {
         }
     }
     /**
-     * This method return the points of the playerTable.
-     * @param playerTable the player table to check.
-     * @return the points of the playerTable.
+     * This method returns the points given to the player after placing a specific gold card on the board.
+     * @param playerTable the player table in which the card is played.
+     * @return the number points obtained.
      */
     @Override
     public int getPoints(PlayerTable playerTable) {
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/Items.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/Items.java
index e9c3f05..2a1dcf5 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/Items.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/Items.java
@@ -1,6 +1,7 @@
 package it.polimi.sw.gianpaolocugola47.model;
 /**
  * This enumeration lists the items.
+ * It includes the name, the image path and the symbol (used for printing symbols in the CLI) of each item.
  */
 public enum Items {
     QUILL("quill","", 'q'),
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/MainTable.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/MainTable.java
index b24ac76..f3a0d60 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/MainTable.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/MainTable.java
@@ -10,7 +10,7 @@ import java.util.List;
 
 /**
  * This class represents the common board, and it contains the scoreboard,
- * the two decks(resources card and gold card) and the common objectives.
+ * the drawable cards present on the table and the common objectives.
  * The status changes are managed by the {@link //Controller}.
  */
 public class MainTable implements Observable {
@@ -24,50 +24,97 @@ public class MainTable implements Observable {
     private int numOfPlayers;
     private final List<Observer> observers;
 
+    /**
+     * Sets the endGame attribute.
+     * @param endGame : true if the game has entered final phase, false otherwise.
+     */
     public void setEndGame(boolean endGame) {
         this.endGame = endGame;
     }
 
+    /**
+     * Returns the drawable cards on the table.
+     * @return : the drawable cards on the table.
+     */
     public ResourceCard[] getCardsOnTable() {
         return cardsOnTable;
     }
 
+    /**
+     * Sets the drawable cards on the table.
+     * @param cardsOnTable : the drawable cards on the table.
+     */
     public void setCardsOnTable(ResourceCard[] cardsOnTable) {
         this.cardsOnTable = cardsOnTable;
     }
 
+    /**
+     * Returns the global objectives.
+     * @return : the global objectives.
+     */
     public Objectives[] getGlobalObjectives() {
         return globalObjectives;
     }
 
+    /**
+     * Sets the global objectives.
+     * @param globalObjectives : the global objectives.
+     */
     public void setGlobalObjectives(Objectives[] globalObjectives) {
         this.globalObjectives = globalObjectives;
     }
 
+    /**
+     * Returns the board points (corresponding to the position on the points board).
+     * @return : the board points.
+     */
     public int[] getBoardPoints() {
         return boardPoints;
     }
 
+    /**
+     * Sets the board points (corresponding to the position on the points board).
+     * @param boardPoints : the board points.
+     */
     public void setBoardPoints(int[] boardPoints) {
         this.boardPoints = boardPoints;
     }
 
+    /**
+     * Returns the global points (corresponding to the points obtained by satisfying the objective's requests).
+     * @return : the global points.
+     */
     public int[] getGlobalPoints() {
         return globalPoints;
     }
 
+    /**
+     * Sets the global points (corresponding to the points obtained by satisfying the objective's requests).
+     * @param globalPoints : the global points.
+     */
     public void setGlobalPoints(int[] globalPoints) {
         this.globalPoints = globalPoints;
     }
 
+    /**
+     * Returns all the player tables.
+     * @return : player table array.
+     */
     public PlayerTable[] getPlayersTables() {
         return playersTables;
     }
 
+    /**
+     * Sets all the player tables.
+     * @param playersTables : player table array.
+     */
     public void setPlayersTables(PlayerTable[] playersTables) {
         this.playersTables = playersTables;
     }
 
+    /**
+     * Constructor. It initializes the main table key parameters and the decks.
+     */
     public MainTable() {
         this.endGame = false;
         this.cardsOnTable = new ResourceCard[4];
@@ -77,12 +124,21 @@ public class MainTable implements Observable {
         initTable();
     }
 
+    /**
+     * Adds an observer to the list of observers.
+     * @param observer : the observer to add.
+     */
     @Override
     public void addObserver(Observer observer) {
         synchronized (observers) {
             this.observers.add(observer);
         }
     }
+
+    /**
+     * Removes an observer from the list of observers.
+     * @param observer : the observer to remove.
+     */
     @Override
     public void removeObserver(Observer observer) {
         synchronized (observers) {
@@ -90,19 +146,45 @@ public class MainTable implements Observable {
         }
     }
 
+    /**
+     * Draws a starting card from the starting deck.
+     * @return : the starting card drawn.
+     */
     public StartingCard drawStartingCard() {
         return Deck.drawCardFromStartingDeck();
     }
 
+    /**
+     * Sets the starting card for a player.
+     * @param playerId : the ID of the player.
+     * @param startingCard : the starting card to set.
+     */
     public void setPlayerStartingCard(int playerId, StartingCard startingCard) {
         this.getPlayerTable(playerId).setStartingCard(startingCard);
     }
+
+    /**
+     * Draws two possible secret objectives from the objectives deck.
+     * @return : the two possible secret objectives to be picked by a player.
+     */
     public Objectives[] drawTwoPossibleSecretObjectives() {
         return new Objectives[]{Deck.drawCardFromObjectivesDeck(), Deck.drawCardFromObjectivesDeck()};
     }
+
+    /**
+     * Sets the secret objective for a player.
+     * @param playerId : the ID of the player.
+     * @param secretObjective : the secret objective to set.
+     */
     public void setPlayerSecretObjective(int playerId, Objectives secretObjective) {
         this.getPlayerTable(playerId).setSecretObjective(secretObjective);
     }
+
+    /**
+     * Initializes the view for all the observers.
+     * It sends the nicknames, the global objectives, the cards on hand and the cards on table.
+     * Observers are used to update the view of each player.
+     */
     @Override
     public void initView() {
         synchronized (observers) {
@@ -110,6 +192,12 @@ public class MainTable implements Observable {
                 observer.initView(getNicknames(), globalObjectives, getCardsOnHand(), cardsOnTable);
         }
     }
+
+    /**
+     * Updates the decks for all the observers.
+     * @param drawPos : the position from which the card was drawn, be it of the drawable on table cards
+     *                or of one of the two decks (Resource and Gold).
+     */
     @Override
     public void updateDecks(int drawPos) {
         new Thread(()->{
@@ -119,6 +207,10 @@ public class MainTable implements Observable {
             }
         }).start();
     }
+
+    /**
+     * Updates the points (both global and board) for all the observers.
+     */
     @Override
     public void updatePoints() {
         new Thread(()->{
@@ -128,6 +220,11 @@ public class MainTable implements Observable {
             }
         }).start();
     }
+
+    /**
+     * Shows the turn for all the observers.
+     * @param playerId : the ID of the player who has the turn.
+     */
     @Override
     public void showTurn(int playerId) {
         new Thread(()->{
@@ -137,6 +234,11 @@ public class MainTable implements Observable {
             }
         }).start();
     }
+
+    /**
+     * Shows the winner for all the observers.
+     * @param winner : the ID of the winner.
+     */
     @Override
     public void showWinner(int winner) {
         new Thread(()->{
@@ -146,6 +248,10 @@ public class MainTable implements Observable {
             }
         }).start();
     }
+
+    /**
+     * Starts the game for all the observers.
+     */
     @Override
     public void startGame() {
         new Thread(()->{
@@ -161,6 +267,10 @@ public class MainTable implements Observable {
         }).start();
     }
 
+    /**
+     * Initializes the table by drawing the resourceCards, the drawable board cards and the
+     * shared objectives.
+     */
     private void initTable(){
         cardsOnTable[0] = Deck.drawCardFromResourceDeck();
         cardsOnTable[1] = Deck.drawCardFromResourceDeck();
@@ -171,7 +281,10 @@ public class MainTable implements Observable {
     }
 
     /**
-     * number of players is set by the first player connected
+     * Sets the number of players in a specific match.
+     * The number of players is set by the first player connected.
+     * It initializes the PlayerTable array with the right dimension.
+     * @param numOfPlayers : the number of players in the match.
      */
     public void setNumOfPlayers(int numOfPlayers) {
         this.numOfPlayers = numOfPlayers;
@@ -180,6 +293,12 @@ public class MainTable implements Observable {
         this.playersTables = new PlayerTable[numOfPlayers];
     }
 
+    /**
+     * Adds a player to the table and initializes its hand by drawing 2 resource cards and a gold card from the
+     * respective deck. The nickname of the player is also set.
+     * @param id : the ID of the player.
+     * @param nickName : the nickname of the player.
+     */
     public void addPlayer(int id, String nickName) {
 
         if(playersTables[id] == null) {
@@ -191,6 +310,10 @@ public class MainTable implements Observable {
         }
     }
 
+    /**
+     * Returns the nicknames of all the players by retrieving them from the player tables.
+     * @return : the nicknames of all the players.
+     */
     public String[] getNicknames() {
         String[] nicknames = new String[numOfPlayers];
         for(int i = 0; i<numOfPlayers; i++) {
@@ -200,31 +323,66 @@ public class MainTable implements Observable {
         }
         return nicknames;
     }
+
+    /**
+     * Returns the cards on hand for all the players by retrieving them from the player tables.
+     * @return : the cards on hand for all the players.
+     */
     public ResourceCard[][] getCardsOnHand() {
         ResourceCard[][] cards = new ResourceCard[numOfPlayers][3];
         for(int i=0; i<numOfPlayers; i++)
             cards[i] = getPlayerTable(i).getCardsOnHand();
         return cards;
     }
+
+    /**
+     * Returns the placed cards for a specific player by retrieving them from the player table.
+     * @param playerId : the ID of the player.
+     * @return : the placed cards for the player, representing its board.
+     */
     public PlaceableCard[][] getPlacedCards(int playerId) {
         return getPlayerTable(playerId).getPlacedCards();
     }
+
+    /**
+     * Returns the resource counter for a specific player by retrieving it from the player table.
+     * @param playerId : the ID of the player.
+     * @return : the resource counter for the player.
+     */
     public int[] getResourceCounter(int playerId) {
         return Arrays.copyOf(getPlayerTable(playerId).getResourceCounter(), 7);
     }
 
+    /**
+     * Turns the specified player's card in the given hand position on its front or back.
+     * @param playerId : the ID of the player.
+     * @param cardPosition : the position of the card in the hand.
+     * @param isFront : true if the card is front, false otherwise.
+     */
     public void turnCardOnHand(int playerId, int cardPosition, boolean isFront) {
         getPlayerTable(playerId).turnCardOnHand(cardPosition, isFront);
     }
 
+    /**
+     * Returns the board points for a specific player.
+     * @param playerId : the ID of the player.
+     * @return :
+     */
     public int getBoardPoints(int playerId) {
         return boardPoints[playerId];
     }
+
+    /**
+     * Returns the global points for a specific player.
+     * @param playerId : the ID of the player.
+     * @return : the global points for the player.
+     */
     public int getGlobalPoints(int playerId) {
         return globalPoints[playerId];
     }
 
     /**
+     * Draws a card from either the deck or the board.
      * @param position 0: draw first resource card,
      *                 1: draw second resource card,
      *                 2: draw first gold card,
@@ -254,6 +412,10 @@ public class MainTable implements Observable {
         this.updateDecks(position);
     }
 
+    /**
+     * Replaces a card on the table with a new one drawn from the respective deck.
+     * @param position : the position of the card to replace.
+     */
     private void replaceCardOnTable(int position){
         if(position == 0 || position == 1)
             cardsOnTable[position] = Deck.drawCardFromResourceDeck();
@@ -261,6 +423,11 @@ public class MainTable implements Observable {
             cardsOnTable[position] = Deck.drawCardFromGoldDeck();
     }
 
+    /**
+     * Checks if a player can play its move.
+     * @param playerId : the ID of the player.
+     * @return : true if the player can play, false otherwise.
+     */
     public boolean checkIfPlayerCanPlay(int playerId) {
         if(playersTables[playerId].getCanPlay()) {
             playersTables[playerId].checkIfCanPlay();
@@ -269,6 +436,11 @@ public class MainTable implements Observable {
         // if canPlay==false it can't be set to true again
     }
 
+    /**
+     * Checks where on the board a player can play its cards.
+     * @param playerId : the ID of the player.
+     * @return : a matrix of booleans representing the playable positions.
+     */
     public boolean[][] checkAllPlayablePositions(int playerId) {
         PlayerTable playerTable = playersTables[playerId];
         boolean[][] matrix = new boolean[PlayerTable.getMatrixDimension()][PlayerTable.getMatrixDimension()];
@@ -280,6 +452,16 @@ public class MainTable implements Observable {
         return matrix;
     }
 
+    /**
+     * Checks if a player can play a card on the table (over an already existing card's corner).
+     * If the card is placed, the respective points (both global board) and  are updated.
+     * @param onHandCard : the position of the card in the hand (0-2).
+     * @param onTableCardX : the row coordinate of the card on the table.
+     * @param onTableCardY : the column coordinate of the card on the table.
+     * @param onTableCardCorner : the corner of the card on the table.
+     * @param playerId : the ID of the player.
+     * @return : true if the player can play the card, false otherwise.
+     */
     public boolean playCardAndUpdatePoints(int onHandCard, int onTableCardX, int onTableCardY, int onTableCardCorner, int playerId) {
         if(playersTables[playerId].getPlacedCard(onTableCardX, onTableCardY) != null) {
             int points = playersTables[playerId].checkAndPlaceCard(onHandCard, onTableCardX, onTableCardY, onTableCardCorner);
@@ -298,25 +480,58 @@ public class MainTable implements Observable {
             return false; // incorrect input: onTableCard is null
         }
     }
+
+    /**
+     * Adds points to the board points of a player.
+     * @param player : the ID of the player.
+     * @param points : the points to add.
+     */
     private void addBoardPoints(int player, int points) {
         this.boardPoints[player] += points;
     }
+    /**
+     * Sets the global points of a player.
+     */
     private void setGlobalPoints(int player, int points) {
         this.globalPoints[player] = points;
     }
+
+    /**
+     * Sets the endGame attribute to true.
+     */
     protected void setEndGame() {
         this.endGame = true;
     }
+
+    /**
+     * Returns the endGame attribute.
+     * @return : true if the game has entered final phase, false otherwise.
+     */
     public boolean getEndGame() {
         return this.endGame;
     }
+
+    /**
+     * Returns the number of players in the match.
+     * @return : the number of players in the match.
+     */
     public int getNumOfPlayers() {
         return this.numOfPlayers;
     }
+
+    /**
+     * Returns the player table of a specific player.
+     * @param index : the ID of the player.
+     * @return : the player table of the specified player.
+     */
     public PlayerTable getPlayerTable(int index) {
         return this.playersTables[index];
     }
 
+    /**
+     * Computes the winner at the end of the game.
+     * @return : the ID of the winner.
+     */
     public int computeWinnerAtEndGame() {
         int winnerPlayerId = 0;
         int max = 0;
@@ -350,11 +565,17 @@ public class MainTable implements Observable {
     }
 
     /**
-     * method used only for testing purposes
+     * Sets the player table in a specified position.
+     * Only used for testing purposes.
      */
     public void setPlayerTable(int i, PlayerTable player) {
         playersTables[i] = player;
     }
+
+    /**
+     * toString method.
+     * @return : the string representation of the main table.
+     */
     @Override
     public String toString() {
         return "MainTable{" +
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/Objectives.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/Objectives.java
index 9c456b8..dd306f2 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/Objectives.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/Objectives.java
@@ -25,26 +25,52 @@ public class Objectives implements Serializable {
         this.imgPathFront = imgPathFront;
         this.imgPathBack = imgPathBack;
     }
+
+    /**
+     * Returns the objectives id.
+     * @return : the id of the objective.
+     */
     public int getId(){
         return id;
     }
 
+    /**
+     * Returns the points of the objective.
+     */
     public int getPoints() {
         return points;
     }
 
+    /**
+     * Returns the image path of the objective, front side.
+     * @return : the image path of the objective.
+     */
     public String getImgPathFront() {
         return imgPathFront;
     }
 
+    /**
+     * Returns the image path of the objective, back side.
+     * @return : the image path of the objective.
+     */
     public String getImgPathBack() {
         return imgPathBack;
     }
 
+    /**
+     * This method checks if the pattern of the player is the same of the objective and if that is true it computes the points.
+     * Implemented in the subclasses.
+     * @param playerTable : the player table of the player.
+     * @return : the points made by the player.
+     */
     public int checkPatternAndComputePoints(PlayerTable playerTable){
         return 0;
     }
 
+    /**
+     * Returns the description of the objective. Used for printing objectives card in the CLI.
+     * @return : the description of the objective.
+     */
     public String getDescription(){
         return description;
     }
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/PlaceableCard.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/PlaceableCard.java
index 3d58d91..9adda9d 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/PlaceableCard.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/PlaceableCard.java
@@ -3,6 +3,11 @@ package it.polimi.sw.gianpaolocugola47.model;
 import java.io.Serializable;
 import java.util.Arrays;
 
+/**
+ * This abstract class represents all the placeable cards in the game.
+ * It includes the front and back image path, the coordinates, the flag for the objective, the corners and the id of the card.
+ * It is inherited by the StartingCard, ResourceCard and GoldCard classes.
+ */
 public abstract class PlaceableCard implements Serializable {
     private boolean isFront;
     private final String backImgPath;
@@ -13,6 +18,11 @@ public abstract class PlaceableCard implements Serializable {
     private final Corner[] corners = new Corner[8];
     private int id;
 
+    /**
+     * PlaceableCard constructor.
+     * @param backImgPath : the path of the back image.
+     * @param frontImgPath : the path of the front image.
+     */
     public PlaceableCard(String backImgPath, String frontImgPath) {
         this.isFront = true;
         this.backImgPath = backImgPath;
@@ -20,52 +30,119 @@ public abstract class PlaceableCard implements Serializable {
         this.isFlaggedForObjective = false;
     }
 
+    /**
+     * Returns the visible corners, meaning the corners of the card that are visible to the player once
+     * the card is placed onto the board; 0-3 are the front corners, 4-7 are the back corners.
+     * @return : the visible corners of the card.
+     */
     public Corner[] getVisibleCorners() {
         if(isFront)
             return Arrays.copyOfRange(corners, 0, 4);
         else return Arrays.copyOfRange(corners, 4, 8);
     }
 
+    /**
+     * Returns the id of the card.
+     * @return : the id of the card.
+     */
     public int getId() {
         return id;
     }
 
+    /**
+     * Sets the coordinates of the card.
+     * @param line : the row of the card.
+     * @param column : the column of the card.
+     */
     public void setCoordinates(int line, int column) {
         this.line = line;
         this.column = column;
     }
+
+    /**
+     * Sets the row of the card.
+     * @return : the row of the card.
+     */
     public int getLine() {return this.line;}
+
+    /**
+     * Returns the column of the card.
+     * @return : the column of the card.
+     */
     public int getColumn() {return this.column;}
 
+    /**
+     * Returns the side of the card.
+     * @return : true if the card is front, false otherwise.
+     */
     public boolean getIsFront() {
         return isFront;
     }
 
+    /**
+     * Returns the path of the back image.
+     * @return : the path of the back image.
+     */
     public String getBackImgPath() {
         return backImgPath;
     }
 
+    /**
+     * Returns the path of the front image.
+     * @return : the path of the front image.
+     */
     public String getFrontImgPath() {
         return frontImgPath;
     }
+
+    /**
+     * Returns whether the card is flagged for the objective.
+     * @return : true if the card is flagged, false otherwise.
+     */
     public boolean getIsFlaggedForObjective(){
         return isFlaggedForObjective;
     }
+
+    /**
+     * Sets the flag for the objective.
+     * @param flag : true if the card is flagged, false otherwise.
+     */
     public void setFlaggedForObjective(boolean flag){
         this.isFlaggedForObjective=flag;
     }
 
+    /**
+     * Switches the side of the card. If the card is front, it becomes back and vice versa.
+     */
     public void switchFrontBack() {
         isFront = !isFront;
     }
+
+    /**
+     * Sets the side of the card.
+     * @param isFront : true if the card is front, false otherwise.
+     */
     public void setFront(boolean isFront) {
         this.isFront = isFront;
     }
 
+    /**
+     * Returns all the corners of the card.
+     * @return : the corners of the card.
+     */
     public Corner[] getCorners() {return corners;}
 
+    /**
+     * Updated the resource counter. Implemented in subclasses.
+     * @param counter : the resource counter.
+     */
     public abstract void updateResourceCounter(int[] counter);
 
+    /**
+     * Returns the points of the card. Implemented in subclasses.
+     * @param playerTable : the player table of the player.
+     * @return : the points of the card.
+     */
     public int getPoints(PlayerTable playerTable) {
         return 0; // default value
     }
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/PlayerTable.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/PlayerTable.java
index 90b3b1f..3bd0f97 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/PlayerTable.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/PlayerTable.java
@@ -51,8 +51,15 @@ public class PlayerTable{
         this.placedCards = new PlaceableCard[MATRIX_DIMENSION][MATRIX_DIMENSION];
     }
 
+    /**
+     * Class PlayerTable's empty constructor.
+     */
     public PlayerTable(){} //for JSON parsing purposes
 
+    /**
+     * Class PlayerTable's constructor.
+     * @param id : the id of the player.
+     */
     public PlayerTable(int id){
         this.id = id;
         this.nickName = "";
@@ -62,50 +69,108 @@ public class PlayerTable{
         this.placedCards = new PlaceableCard[MATRIX_DIMENSION][MATRIX_DIMENSION];
     }
 
+    /**
+     * This method returns the matrix dimension. The matrix is a square, so both borders are equal.
+     * @return : the matrix dimension.
+     */
     public static int getMatrixDimension() {
         return MATRIX_DIMENSION;
     }
 
+    /**
+     * This method returns the starting card position. It is at the centre of the board,
+     * so row and column position are the same.
+     * @return : the starting card position.
+     */
     public static int getStartingCardPos() {return STARTING_CARD_POS;}
 
+    /**
+     * Returns the player's id.
+     * @return : the id of the player.
+     */
     public int getId() {
         return id;
     }
 
+    /**
+     * Sets the player's id.
+     * @param id : the id of the player.
+     */
     public void setId(int id) {this.id = id;}
 
+    /**
+     * Returns the player's nickname.
+     * @return : the nickname of the player.
+     */
     public String getNickName() {
         return nickName;
     }
 
+    /**
+     * Returns whether the player can play or not.
+     * @return : true if the player can play, false otherwise.
+     */
     public boolean getCanPlay(){return canPlay;}
 
+    /**
+     * Sets the player's canPlay attribute.
+     * @param canPlay : true if the player can play, false otherwise.
+     */
     public void setCanPlay(boolean canPlay) {
         this.canPlay = canPlay;
     }
 
+    /**
+     * Sets the player's resource counter. Used when parsing from json.
+     * @param resourceCounter : the resource counter of the player.
+     */
     public void setResourceCounter(int[] resourceCounter) {
         this.resourceCounter = resourceCounter;
     }
 
+    /**
+     * Returns the player's resource counter.
+     * @return : the resource counter of the player.
+     */
     public int[] getResourceCounter() {return resourceCounter;}
 
+    /**
+     * This method returns the resource counter of a specific resource.
+     * @param position : the position of the resource in the resource counter.
+     * @return : the resource counter of the player.
+     */
     protected int getResourceCounter(int position) {
         return resourceCounter[position];
     }
 
+    /**
+     * This method sets the secret objective of the player.
+     * @return : the player's secret objective.
+     */
     public Objectives getSecretObjective() {
         return secretObjective;
     }
 
+    /**
+     * This method sets the secret objective of the player.
+     * @param objective : the player's secret objective.
+     */
     public void setSecretObjective(Objectives objective){
         this.secretObjective = objective;
     }
 
+    /**
+     * This method sets the starting card of the player.
+     * @return : the player's starting card.
+     */
     public StartingCard getStartingCard() {
         return startingCard;
     }
 
+    /**
+     * This method sets the starting card of the player and updates the resource counter.
+     * @param startingCard : the player's starting card.
+     */
     public void setStartingCard(StartingCard startingCard){
         this.startingCard = startingCard;
         this.placedCards[STARTING_CARD_POS][STARTING_CARD_POS] = this.startingCard;
@@ -113,24 +178,51 @@ public class PlayerTable{
         startingCard.updateResourceCounter(this.resourceCounter);
     }
 
+    /**
+     * This method returns the cards on the player's hand.
+     * @return : the cards on the player's hand.
+     */
     public ResourceCard[] getCardsOnHand(){return cardsOnHand;}
 
+    /**
+     * This method returns the card on the player's hand at a specific position.
+     * @param position : the position of the card on the player's hand.
+     * @return : the card on the player's hand at the specified position.
+     */
     public ResourceCard getCardOnHand(int position) {
         return cardsOnHand[position];
     }
 
+    /**
+     * This method returns the cards placed on the player's board.
+     * @return : the cards matrix placed on the player's board.
+     */
     public PlaceableCard[][] getPlacedCards(){
         return placedCards;
     }
 
+    /**
+     * This method returns the card placed on the player's board at a specific position.
+     * @param x : row coordinate.
+     * @param y : column coordinate.
+     * @return : the card placed on the player's board at the specified position.
+     */
     public PlaceableCard getPlacedCard(int x, int y) {
         return this.placedCards[x][y];
     }
 
+    /**
+     * This method sets a new placed card matrix, replacing the old one.
+     * @param placedCards : the cards matrix placed on the player's board.
+     */
     public void setPlacedCards(PlaceableCard[][] placedCards) {
         this.placedCards = placedCards;
     }
 
+    /**
+     * Checks whether the hand of a player has a null card and places a given card there.
+     * @param card : the card to be placed.
+     */
     public void setCardOnHandInTheEmptyPosition(ResourceCard card) {
         for(int i=0; i<3; i++){
             if(this.cardsOnHand[i] == null) {
@@ -140,6 +232,11 @@ public class PlayerTable{
         }
     }
 
+    /**
+     * Changes the side of the card in the specified hand position.
+     * @param isFront : true if the card is front, false otherwise.
+     * @param cardPosition : position of the card in the player's hand that is to be switched.
+     */
     public void turnCardOnHand(int cardPosition, boolean isFront){
         this.cardsOnHand[cardPosition].setFront(isFront);
     }
@@ -170,6 +267,16 @@ public class PlayerTable{
         points = card.getPoints(this);
         return points;
     }
+
+    /**
+     * This method sets the x coordinate of a card depending on the corner.
+     * If a card is to be placed on the top corners of the card (0,1), this method returns
+     * x - 1, since the card to be placed will be on the row above the card already on the board;
+     * Corners 2 and 3 are the bottom corners, so the x coordinate is x + 1.
+     * @param x : row coordinate of the card already present on the board.
+     * @param corner : corner of the card already present on the board that is to be covered by the new card.
+     * @return : the x coordinate of the card to be placed. -1 if the input is incorrect.
+     */
     public int setXCoordinate(int x, int corner){
         if(corner==0||corner==1)
             return x-1;
@@ -178,6 +285,16 @@ public class PlayerTable{
         else
             return -1; // incorrect input: corner!=0,1,2,3
     }
+
+    /**
+     * This method sets the y coordinate of a card depending on the corner.
+     * If a card is to be placed on the left corners of the card (0,2), this method returns
+     * y - 1, since the card to be placed will be on the column to the left of the card already on the board;
+     * Corners 1 and 3 are the right corners, so the y coordinate is y + 1.
+     * @param y : column coordinate of the card already present on the board.
+     * @param corner : corner of the card already present on the board that is to be covered by the new card.
+     * @return : the y coordinate of the card to be placed. -1 if the input is incorrect.
+     */
     public int setYCoordinate(int y, int corner){
         if(corner==0||corner==2)
             return y-1;
@@ -186,6 +303,13 @@ public class PlayerTable{
         else
             return -1; // incorrect input: corner!=0,1,2,3
     }
+
+    /**
+     * This method checks if a card can be placed on the table at the given coordinates.
+     * @param x : row coordinate of the card to be placed.
+     * @param y : column coordinate of the card to be placed.
+     * @return : true if the card can be placed, false otherwise.
+     */
     public boolean isPlaceable(int x, int y) {
         if(this.placedCards[x][y] == null && hasAtLeastOneSurroundingCard(x,y)){
                 int cornersVerified = 0;
@@ -199,6 +323,13 @@ public class PlayerTable{
         }else
             return false; // card is null OR all cards around card are null
     }
+
+    /**
+     * This method checks if a card in x,y has at least one other card around.
+     * @param x : row coordinate of the card.
+     * @param y : column coordinate of the card.
+     * @return : true if the card has at least one surrounding card, false otherwise.
+     */
     private boolean hasAtLeastOneSurroundingCard(int x, int y){
         for(int corner=0; corner<4; corner++){
             if(corner==0 && (x==0 || y==0))
@@ -215,6 +346,14 @@ public class PlayerTable{
         }
         return false; // all surrounding cards are null
     }
+
+    /**
+     * This method checks if a card is on matrix's edge and if the corner is valid.
+     * @param x : row coordinate of the card.
+     * @param y : column coordinate of the card.
+     * @param corner : corner of the card to be checked.
+     * @return : true if the corner is valid or if the card is null, false otherwise.
+     */
     private boolean checkCorner(int x, int y, int corner){
         // this method checks only ONE corner, to check all corners it is to be called 4 times
         x=setXCoordinate(x, corner);
@@ -252,6 +391,13 @@ public class PlayerTable{
         }else
             return true; // card is null
     }
+
+    /**
+     * This method checks if there are enough resources on the board to place a ResourceCard on the table.
+     * Once the card is placed, the resource counter is updated.
+     * @param card : the gold card to be placed.
+     * @return : true if there are enough resources, false otherwise.
+     */
     private boolean isCheap(GoldCard card) {
         int[] resCounter = new int[Resources.values().length];
         System.arraycopy(this.resourceCounter, 0, resCounter, 0, Resources.values().length); // resCounter only of Resources
@@ -261,6 +407,13 @@ public class PlayerTable{
         sort(resCounter);
         return resCounter[0] >= 0; // true: I have enough resources
     }
+
+    /**
+     * This method places a card on the table and links it to the surrounding cards.
+     * @param x : row coordinate of the card to be placed.
+     * @param y : column coordinate of the card to be placed.
+     * @param card : the card to be placed.
+     */
     private void placeCard(int x, int y, ResourceCard card) {
         this.placedCards[x][y]=card;
         card.setCoordinates(x,y);
@@ -268,6 +421,13 @@ public class PlayerTable{
         for (int corner = 0; corner < 4; corner++)
             linkCards(x, y, corner);
     }
+
+    /**
+     * This method links a card to the board card it is placed over.
+     * @param x : row coordinate of the card on board.
+     * @param y : column coordinate of the card on board.
+     * @param corner : corner of the card on board.
+     */
     private void linkCards(int x,int y, int corner) {
         // mirror-links ONE corner for 2 cards, to link 4 corners it is to be called 4 times
         if(this.placedCards[setXCoordinate(x,corner)][setYCoordinate(y,corner)]!=null) {
@@ -281,6 +441,13 @@ public class PlayerTable{
                 linkCard(x, y, corner);
         }
     }
+
+    /**
+     * This method links a corner of a card to the corner of another card.
+     * @param x : row coordinate of the card on the board.
+     * @param y : column coordinate of the card on the board.
+     * @param corner : corner of the card on the board.
+     */
     private void linkCard(int x, int y, int corner){
         // links corner AND decrease ResourceCounter[]
         this.placedCards[setXCoordinate(x, corner)][setYCoordinate(y, corner)].getVisibleCorners()[3-corner].setIsCovered();
@@ -288,6 +455,11 @@ public class PlayerTable{
         this.placedCards[setXCoordinate(x, corner)][setYCoordinate(y, corner)].getVisibleCorners()[3-corner].setLinkedCorner(this.placedCards[x][y].getVisibleCorners()[corner]);
         this.placedCards[x][y].getVisibleCorners()[corner].setLinkedCorner(this.placedCards[setXCoordinate(x, corner)][setYCoordinate(y, corner)].getVisibleCorners()[3-corner]);
     }
+
+    /**
+     * This method decreases the resource counter of the player.
+     * @param corner : the corner that got covered once another card is placed over it.
+     */
     private void decreaseResourceCounter(Corner corner) {
         if(corner.isResource()){
             this.resourceCounter[corner.getResource().ordinal()]--;
@@ -296,6 +468,11 @@ public class PlayerTable{
         }
     }
 
+    /**
+     * This method returns the points made by the player with both the secret and the shared objectives.
+     * @param objectives : the shared objectives of the game.
+     * @return : the points made by the player.
+     */
     public int getObjectivePoints(Objectives[] objectives){
         int points = getSecretObjectivePoints();
         for (Objectives objective : objectives) {
@@ -303,10 +480,19 @@ public class PlayerTable{
         }
         return points;
     }
+
+    /**
+     * This method returns the points made by the player with the secret objective.
+     * @return : the points made by the player with the secret objective.
+     */
     private int getSecretObjectivePoints(){
         return this.secretObjective.checkPatternAndComputePoints(this);
     }
 
+    /**
+     * Checks if the player can play any card on the board. If the board is full, the player is stuck.
+     * Sets canPlay to false if the player can't play any card.
+     */
     public void checkIfCanPlay(){
         for (int i=0; i<getMatrixDimension(); i++){
             for (int j=0; j<getMatrixDimension(); j++){
@@ -321,6 +507,13 @@ public class PlayerTable{
             }
         }
     }
+
+    /**
+     * Checks whether the player can place a card over a specific board card or not.
+     * @param x : row coordinate of the card on the board.
+     * @param y : column coordinate of the card on the board.
+     * @return : true if the player can place a card over the board card, false otherwise.
+     */
     private boolean checkIfCanPlayOnCard(int x, int y){
         if (this.placedCards[x][y]!=null){
             for (int corner=0; corner<4; corner++){
@@ -339,16 +532,35 @@ public class PlayerTable{
         }return false; // incorrect input :card is null
     }
 
+    /**
+     * Sets the player's nickname.
+     * @param nicknameLocal : the player's nickname.
+     */
     public void setNickname(String nicknameLocal) { this.nickName = nicknameLocal; }
 
+    /**
+     * Sets the player's cardsOnHand.
+     * @param cardsOnHand : the cards on the player's hand.
+     */
     public void setCardsOnHand(ResourceCard[] cardsOnHand) {
         this.cardsOnHand = cardsOnHand;
     }
 
+    /**
+     * Sets a card on a player's specific hand position.
+     * @param position : hand's position.
+     * @param cardOnHand : the card to be set in that position.
+     */
     public void setCardOnHand(int position, ResourceCard cardOnHand){
         this.cardsOnHand[position] = cardOnHand;
     }
 
+    /**
+     * Used for serializing the player table to json, since the PlacedCard matrix is not serializable.
+     * Returns a int matrix with card's id are present at the coordinates of the respective cards,
+     * and -1 is set where the position is null.
+     * @return : the card id matrix.
+     */
     public int[][] getCardIdMatrix(){
         int[][] cardIdMatrix = new int[MATRIX_DIMENSION][MATRIX_DIMENSION];
         for(int i=0; i<MATRIX_DIMENSION; i++){
@@ -362,6 +574,12 @@ public class PlayerTable{
         return cardIdMatrix;
     }
 
+    /**
+     * Used for serializing the player table to json, since the PlacedCard matrix is not serializable.
+     * Returns a boolean matrix where empty positions and back-played cards' positions are set false
+     * and front-played cards' are set true.
+     * @return : th
+     */
     public boolean[][] getCardSideMatrix() {
         boolean[][] cardSideMatrix = new boolean[MATRIX_DIMENSION][MATRIX_DIMENSION];
         for(int i=0; i<MATRIX_DIMENSION; i++){
@@ -375,6 +593,14 @@ public class PlayerTable{
         return cardSideMatrix;
     }
 
+    /**
+     * This method is used to convert the id matrix and the side matrix to the card matrix.
+     * If the id is set to -1 in the id matrix, null is placed at those coordinates. The card with the respective id
+     * is set to the correct side and then placed and linked with the remaining cards elsewhere.
+     * A resource counter parameter is used to correctly update the resource counter of the player, since
+     * the placeStartingCard method overrides it and doubles the resources when loading from json.
+     * @param resourceCounterParameter : the resource counter of the player, loaded from the json file.
+     */
     public void idMatrixToCardMatrix(int[] resourceCounterParameter){ //to be called ONLY when parsing the id matrix from json
         this.placedCards = new PlaceableCard[MATRIX_DIMENSION][MATRIX_DIMENSION];
         int[] tempResCounter = new int[resourceCounterParameter.length];
@@ -413,14 +639,26 @@ public class PlayerTable{
         this.cardSideMatrix = null;
     }
 
+    /**
+     * This method sets the card id matrix. Used when parsing from json.
+     * @param cardIdMatrix : the card id matrix.
+     */
     public void setCardIdMatrix(int[][] cardIdMatrix) {
         this.cardIdMatrix = cardIdMatrix;
     }
 
+    /**
+     * This method sets the card side matrix. Used when parsing from json.
+     * @param cardSideMatrix : the card side matrix.
+     */
     public void setCardSideMatrix(boolean[][] cardSideMatrix) {
         this.cardSideMatrix = cardSideMatrix;
     }
 
+    /**
+     * This method returns the player's board as a string.
+     * @return : the player's board as a string.
+     */
     @Override
     public String toString() {
         return "PlayerTable{" +
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/ResourceCard.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/ResourceCard.java
index bb0b6ad..a997bc3 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/ResourceCard.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/ResourceCard.java
@@ -24,6 +24,11 @@ public class ResourceCard extends PlaceableCard {
         return this.resourceCentreBack;
     }
 
+    /**
+     * This method returns the points given to the player after placing a specific resource card on the board.
+     * @param playerTable : the player table of the player that placed the card.
+     * @return : the number of points obtained.
+     */
     public int getPoints(PlayerTable playerTable){
         if(this.getIsFront())
             return this.points;
@@ -32,6 +37,12 @@ public class ResourceCard extends PlaceableCard {
         // nothing else needed
     }
 
+    /**
+     * This method returns the points attribute.
+     * If the card is placed on the back, it gives no points; otherwise, it returns the number of
+     * points specified by the respective attribute.
+     * @return : the number of points obtained.
+     */
     public int getThisPoints(){
         if(this.getIsFront())
             return this.points;
@@ -39,6 +50,10 @@ public class ResourceCard extends PlaceableCard {
             return 0;
     }
 
+    /**
+     * This method updates the resource counter after a card is placed.
+     * @param counter : the counter to update.
+     */
     @Override
     public void updateResourceCounter(int[] counter) {
         if(getIsFront()){
@@ -57,6 +72,11 @@ public class ResourceCard extends PlaceableCard {
         }
     }
 
+    /**
+     * This method returns the resourceCentreBack attribute formatted using ASCII escape codes.
+     * Used for printing resource cards in the CLI.
+     * @return : the resourceCentreBack attribute formatted using ASCII escape codes.
+     */
     public String resourceCentreBackToString(){
         return "%s%s\u001B[0m".formatted(resourceCentreBack.getAsciiEscape(), resourceCentreBack.getSymbol());
     }
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/ResourceObjective.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/ResourceObjective.java
index a407c3f..e5cc9fd 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/ResourceObjective.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/ResourceObjective.java
@@ -18,10 +18,19 @@ public class ResourceObjective extends Objectives{
         this.resource = resource;
     }
 
+    /**
+     * Returns the resource needed to receive points.
+     * @return : the resource needed to receive points.
+     */
     public Resources getResource() {
         return resource;
     }
 
+    /**
+     * Checks if the player table contains the required resource three times and computes the points.
+     * @param playerTable : the player table of the player.
+     * @return : the points made by the player.
+     */
     @Override
     public int checkPatternAndComputePoints(PlayerTable playerTable) {
         // 1 resourceSet is 3 resources
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/Resources.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/Resources.java
index 9278e51..e0c0552 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/Resources.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/Resources.java
@@ -1,6 +1,7 @@
 package it.polimi.sw.gianpaolocugola47.model;
 /**
  * This enumeration lists the resources of a card.
+ * It includes the colour, the image path, the ASCII escape code and the symbol (used for printing symbols in the CLI) of each resource.
  */
 public enum Resources {
     ANIMAL("blue","","\033[0;34m", 'A'),
diff --git a/src/main/java/it/polimi/sw/gianpaolocugola47/model/StartingCard.java b/src/main/java/it/polimi/sw/gianpaolocugola47/model/StartingCard.java
index edd37b0..6ef87b1 100644
--- a/src/main/java/it/polimi/sw/gianpaolocugola47/model/StartingCard.java
+++ b/src/main/java/it/polimi/sw/gianpaolocugola47/model/StartingCard.java
@@ -19,10 +19,19 @@ public class StartingCard extends PlaceableCard {
         setCoordinates(PlayerTable.getStartingCardPos(), PlayerTable.getStartingCardPos());
     }
 
+    /**
+     * Sets the resources of the centre back of the card.
+     * @return : the resources of the centre back of the card.
+     */
     public ArrayList<Resources> getResourcesCentreBack() {
         return this.resourcesCentreBack;
     }
 
+    /**
+     * This method return the resourcesCentreBack attribute in a string format using ASCII escape codes to
+     * represent the respective colors. Used for printing starting cards in the CLI.
+     * @return : the resourcesCentreBack attribute in a string format.
+     */
     public String resourcesCentreBackToString(){
         StringBuilder retString = new StringBuilder();
         if(resourcesCentreBack.size() == 1){
@@ -35,7 +44,7 @@ public class StartingCard extends PlaceableCard {
         else if (resourcesCentreBack.size() == 2){
             retString.append("  ");
             for(Resources resource : resourcesCentreBack){
-                retString.append("%s %s\u001B[0m".formatted(resource.getAsciiEscape(), resource.getSymbol()));
+                retString.append("%s%s\u001B[0m".formatted(resource.getAsciiEscape(), resource.getSymbol()));
             }
             retString.append("  ");
         }
@@ -49,6 +58,10 @@ public class StartingCard extends PlaceableCard {
         return retString.toString();
     }
 
+    /**
+     * Updates the resource counter once the starting card is placed.
+     * @param counter : the resource counter.
+     */
     @Override
     public void updateResourceCounter(int[] counter) {
         if(getIsFront()) {
@@ -68,6 +81,10 @@ public class StartingCard extends PlaceableCard {
         }
     }
 
+    /**
+     * String representation of the starting card.
+     * @return : the string representation of the starting card.
+     */
     public String toString(){
         return "StartingCard: resources: "+resourcesCentreBack.toString();
     }
